---
layout: post
title: Java解惑
---

# Java解惑

---

## 第2章 表达式之谜
1. 奇数性
```java
public static boolean isOdd(int i) {
	return i % 2 == 1;
}
```
当取余操作返回一个非零的结果时，它与左操作数具有相同的正负符号。
当i是一个负奇数时，i%2等于-1而不是1。
```java
public static boolean isOdd(int i) {
    return i % 2 != 0;
}
```
2. 找零时刻
```java
public class Change {
	public static void main(String[] args) {
		System.out.println(2.00-1.10);
	}
}
```
问题在于1.1这个数字不能被精确表示为一个double，因此被表示为最接近它的double值。
并不是所有的小数都可以用二进制浮点数精确表示。
二进制浮点对于货币计算是非常不合适的。
解决该问题的一种方式是使用某种整数类型。
解决该问题的另一种方式是使用执行精确小数运算的BigDecimal。
一定要用BigDecimal(String)构造器，而千万不要用BigDecimal(double)。
在需要精确答案的地方，要避免使用float和double；对于货币计算，要使用int、long或BigDecimal。
3. 长整除
```java
public class LongDivision {
	public static void main(String[] args) {
		final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
		final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
		System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
	}
}
```
	final long MICROS_PER_DAY = 24L * 60 * 60 * 1000 * 1000;
	final long MILLIS_PER_DAY = 24L * 60 * 60 * 1000;
当在操作很大的数字时，千万要提防溢出——它可是一个缄默杀手。
4. 初级问题
```java
public class Elementary {
	public static void main(String[] args) {
		System.out.println(12345 + 5432l);
	}
}
```
在long类型字面常量中，一定要用大写的L，千万不要用小写的l。
要避免使用单个l字母作为变量名。
5. 十六进制的趣事
```java
public class JoyOfHex {
	public static void main(String[] args) {
		System.out.println(Long.toHexString(0x100000000L + 0xcafebabe));
	}
}
```
负的十进制常量可以很明确地用一个减号来标识。
如果十六进制和八进制字面常量的最高位被置位了，那么它们就是负数。
System.out.println(Long.toHexString(0x100000000L + 0xcafebabeL));
通常最好是避免混合类型的计算。
6. 多重转型
```java
public class Multicast {
	public static void main(String[] args) {
		System.out.println((int)(char)(byte)-1);
	}
}
```
如果最初的数值类型是有符号的，就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。
7. 互换内容
```java
public class CleverSwap {
	public static void main(String[] args) {
		int x = 1984;
		int y = 2001;
		x ^= y ^= x ^= y;
		System.out.println("x="+x+";y="+y);
	}
}
```
C/C++中运行正确。Java中不正确。
操作符的操作数是从左向右求值的。
实际运行过程如下：
```java
int tmp1 = x;
int tmp2 = y;
int tmp3 = x ^ y;
x = tmp3;
y = tmp2 ^ tmp3;
x = tmp1 ^ y;
y = (x ^= (y ^= x)) ^ y;
```
在单个表达式中不要对相同的变量赋值两次。
8. Dos Equis
```java
public class DosEquis {
	public static void main(String[] args) {
		char x= 'X';
		int i = 0;
		System.out.println(true ? x : 0);
		System.out.println(false ? i : x);
	}
}
```
混合类型的计算会引起混乱，而这一点在条件表达式中比在其他任何地方都表现得更明显。
确定条件表达式结果类型的规则：
（1） 如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型。
（2） 如果一个操作数的类型是T，T表示byte、short、或char，而另一个操作数是一个int类型的常数表达式，它的值可以用类型T表示，那么条件表达式的类型就是T。
（3） 否则，将对操作数类型进行二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型。
将final修饰符用于i的声明可以把i转变为一个常量表达式。
在条件表达式中使用类型相同的第二个和第三个操作数。
9. 半斤
```java
x += i;
x = x + i;
```
复合赋值E1 op= E2等价于简单赋值E1=(T)((E1)op(E2))，其中T是E1的类型。
复合赋值表达式自动将所执行计算的结果转型为其左侧变量的类型。
请不要将复合赋值操作符作用于byte、short或char类型的变量。在将复合赋值操作符作用于int类型的变量上时，要确保表达式右侧不是long、float或double类型。在将复合赋值操作符作用于float类型的变量上时，要确保表达式右侧不是double类型。
10. 八两
```java
x = x + i;
x += i;
```
如果在+=操作符左侧的操作数是String类型的，那么它允许右侧的操作数是任意类型。
简单赋值操作符（=）允许其左侧的是对象引用类型，只要表达式的右侧与左侧的变量时赋值兼容的即可。
## 第3章 字符之谜
11. 最后的笑声
```java
public class LastLaugh {
	public static void main(String[] args) {
		System.out.println("H" + "a");
		System.out.println('H' + 'a');
	}
}
```
当且仅当+操作符的操作数中至少有一个是String类型时，才会执行字符串连接操作。
    System.out.println("2+2="+2+2);
12. ABC
```java
public class Abc {
	public static void main(String[] args) {
		String letters = "ABC";
		char[] numbers = {'1', '2', '3'};
		System.out.println(letters + " easy as " + numbers);
	}
}
```
	System.out.println(numbers);
要想将一个char数组转换成一个字符串，就要调用String.valueOf(char[])方法。
13. 动物庄园
```java
public class AnimalFarm {
	public static void main(String[] args) {
		final String pig = "length:10";
		final String dog = "length:" + pig.length();
		System.out.println("Animals are equal:" + pig == dog);
	}
}
```
+比==的优先级高。
在使用字符串连接操作符时，总是将重要的操作数用括号括起来。
在比较对象引用时，应该优先使用equals方法而不是==操作符，除非需要比较的是对象的标识而不是对象的值。
14. 转义字符的溃败
```java
public class EscapeRout {
	public static void main(String[] args) {
		// \u0022 is the Unicode escape for double quote (")
		System.out.println("a\u0022.length()+\u0022b".length());	}
}
```
Java对在字符串字面常量中的Unicode转义字符没有提供任何特殊处理。
在字符串和字符字面常量中优先选择的是转义字符序列，而不是Unicode转义字符。
不要使用Unicode转义字符来表示ASCII字符。
15. 令人晕头转向的Hello
```java
/**
 * Generated by the IBM IDL-to-Java compiler, version 1.0
 * from F:\TestRoot\apps\a1\units\include\PolicyHome.idl
 * Wednesday, June 17, 1998 6:44:40 o'clock AM GMT+00:00
 */
public class Test {
	public static void main(String[] args) {
		System.out.print("Hell");
		System.out.println("o world");
	}
}
```
问题在于注释的第三行，它包含了字符\units。
Unicode转义字符必须是良构的，即使出现在注释中也是如此。
在Javadoc注释中，应该使用HTML实体转义字符来代替Unicode转义字符。
工具应该确保不将Windows文件名置于所生成的Java源文件的注释中。
16. 行打印程序
```java
public class LinePrinter {
	public static void main(String[] args) {
		// Note: \u000A is Unicode representation of linefeed (LF)
		char c = 0x000A;
		System.out.println(c);
	}
}
```
第三行的注释
除非确实是必需的，否则就不要用使用Unicode转义字符。
17. 嗯？
只有在你要向程序中插入用其他任何方式都无法表示的字符时，Unicode转义字符才是必需的，除此之外的任何情况都应该避免使用它们。
18. 字符串奶酪
```java
public class StringCheese {
	public static void main(String[] args) {
		byte[] bytes = new byte[256];
		for (int i = 0; i < 256; i++)
			bytes[i] = (byte) i;
		String str = new String(bytes);
		for (int i = 0, n = str.length(); i < n; i++)
			System.out.print((int) str.charAt(i) + " ");
	}
}
```
在char序列和byte序列之间转换时，可以且通常应该显式地指定字符集。
每当要将一个byte序列转换成一个String时，你都在使用一个字符集，不管是否显式指定了它。
19. 漂亮的火花（块注释符）
```java
public class Classifier {
	public static void main(String[] args) {
		System.out.println(classify('n') + classify('+') + classify('2'));
	}

	static String classify(char ch) {
		if ("0123456789".indexOf(ch) >= 0)
			return "NUMERAL ";
		if ("abcdefghijklmnopqrstuvwxyz".indexOf(ch) >= 0)
			return "LETTER ";
		/* (Operators not supported yet)
		if ("+-*/&|!=".indexOf(ch) >= 0)
		return "OPERATOR ";
		*/
		return "UNKNOWN ";
	}
}
```
在注释中没有特殊处理字符串字面常量。
块注释不能嵌套。
注释掉代码段的最好方式是使用单行的注释序列。
块注释不能可靠地注释掉代码段。
20. 我的类是什么
```java
public class Me {
	public static void main(String[] args) {
		System.out.println(Me.class.getName().replaceAll(".", "/") + ".class");
	}
}
```
String.replaceAll接受了一个正则表达式作为它的第一个参数。正则表达式”.”可以匹配任何单个的字符。
```java
Me.class.getName().replaceAll("\\.", "/");
System.out.println(Me.class.getName().replaceAll(Pattern.quote("."), "/") + ".class");
```
21. 我的类是什么？镜头2
```java
public class MeToo {
	public static void main(String[] args) {
		System.out.println(MeToo.class.getName().replaceAll("\\.",
				File.separator)
				+ ".class");
	}
}
```
第二个参数不是一个普通的字符串，而是一个替代字符串。在替代字符串中出现的反斜杠会把紧随其后的字符进行转义，从而导致其被按字面含义而处理了。
```java
System.out.println(MeToo.class.getName().replaceAll("\\.",
    Matcher.quoteReplacement(File.separator))
    + ".class");
System.out.println(MeToo.class.getName().replace(".", File.separator)     + ".class");
System.out.println(MeToo.class.getName().replace('.',                    File.separatorChar) + ".class");
```
在使用不熟悉的类库方法时一定要格外小心。
22. URL的愚弄
```java
public class BrowserTest {
	public static void main(String[] args) {
		System.out.print("iexplore:");
		http: // www.google.com;
		System.out.println(":maximize");
	}
}
```
在程序中间出现的URL是一个语句标号（statement label）后面跟着尾注释（end-of-line comment）。
仔细地写注释，并让它们跟上时代；去除那些已遭废弃的代码。
23. 不劳而获
```java
public class Rhymes {
	private static Random rnd = new Random();

	public static void main(String[] args) {
		StringBuffer word = null;
		switch (rnd.nextInt(2)) {
		case 1:
			word = new StringBuffer('P');
		case 2:
			word = new StringBuffer('G');
		default:
			word = new StringBuffer('M');
		}
		word.append('a');
		word.append('i');
		word.append('n');
		System.out.println(word);
	}
}
```
要当心栅栏柱错误。
不要从一个非空的case向下进入另一个case。
不管在什么时候，都要尽可能使用熟悉的惯用法和API。如果必须使用不熟悉的API，那么请仔细阅读其文档。
```java
		switch (rnd.nextInt(3)) {
		case 1:
			word = new StringBuffer("P");
			break;
		case 2:
			word = new StringBuffer("G");
			break;
		default:
			word = new StringBuffer("M");
			break;
		}

System.out.println("PGM".charAt(rnd.nextInt(3)) + "ain");

public class Rhymes {
	public static void main(String args[]) {
		String a[] = { "Main", "Pain", "Gain" };
		System.out.println(randomElement(a));
	}

	private static Random rnd = new Random();

	private static String randomElement(String[] a) {
		return a[rnd.nextInt(a.length)];
	}
}
```
char不是String，而是更像int。
要提防各种诡异的谜题。
## 第4章 循环之谜
24.	尽情享受每一个字节
```java
public class BigDelight {
	public static void main(String[] args) {
		for (byte b = Byte.MIN_VALUE; b < Byte.MAX_VALUE; b++) {
			if (b == 0x90)
				System.out.print("Joy!");
		}
	}
}

if (b == (byte)0x90)	System.out.print("Joy!");

if ((b & 0xff) == 0x90)	System.out.print("Joy!");

private static final byte TARGET = (byte) 0x90; 
if (b == TARGET)	System.out.print("Joy!");
```
要避免混合类型比较，因为它们内在地容易引起混乱。
请使用声明的常量替代“魔数”。
25.	无情的增量操作
```java
public class Increment {
	public static void main(String[] args) {
		int j = 0;
		for (int i = 0; i < 100; i++)
			j = j++;
		System.out.println(j);
	}
}
```
不要在单个表达式中对相同的变量赋值超过一次。
26.	在循环中
```java
public class InTheLoop {
	public static final int END = Integer.MAX_VALUE;
	public static final int START = END - 100;

	public static void main(String[] args) {
		int count = 0;
		for (int i = START; i <= END; i++)
			count++;
		System.out.println(count);
	}
}

for (long i = START; i <= END; i++)
```
无论你在何时使用了一个整数类型，都要意识到其边界条件。
```java
int i = START;
do {
	count++;
} while (i++ != END);
```
27.	变幻莫测的i值
```java
public class Shifty {
	public static void main(String[] args) {
		int i = 0;
		while(-1 << i != 0)
			i++;
		System.out.println(i);
	}
}
```
移位操作符只使用其右操作数的低5位作为移位长度。或者是低6位，如果其左操作数是一个long类型数值。
28.	就
29.	Gf
30.	D
31.	G
32.	G
33.	G
34.	G
35.	G
## 第5章 异常之谜
36.	F
37.	F
38.	F
39.	F
40.	F
41.	F
42.	F
43.	F
44.	F
45.	F

## 第6章 类之谜
46.	令人混淆的构造器案例
```java
public class Confusing {
	private Confusing(Object o) {
		System.out.println("Object");
	}

	private Confusing(double[] dArray) {
		System.out.println("double array");
	}

	public static void main(String[] args) {
		new Confusing(null);
	}
}
```
Java的重载解析过程是分两阶段运行的。第一阶段选取所有可获得并且可应用的方法或构造器。第二阶段在第一阶段选取的方法或构造器中选取最精确的一个。
在测试哪一个方法或构造器最精确时，并没有使用实参。
要想强制要求编译器选择一个精确的重载版本，需要将实参转型为形参所声明的类型。
避免使用重载。
47. 啊呀！狸猫变犬子
```java
class Counter {
	private static int count;

	public static void increment() {
		count++;
	}

	public static int getCount() {
		return count;
	}
}

class Dog extends Counter {
	public Dog() {
	}

	public void woof() {
		increment();
	}
}

class Cat extends Counter {
	public Cat() {
	}

	public void meow() {
		increment();
	}
}

public class Ruckus {
	public static void main(String[] args) {
		Dog[] dogs = { new Dog(), new Dog() };
		for (int i = 0; i < dogs.length; i++)
			dogs[i].woof();
		Cat[] cats = { new Cat(), new Cat(), new Cat() };
		for (int i = 0; i < cats.length; i++)
			cats[i].meow();
		System.out.print(Dog.getCount() + " woofs and ");
		System.out.println(Cat.getCount() + " meows");
	}
}
```
每一个静态字段在声明它的类及其所有子类中共享一份单一的副本。
优选组合而不是继承。
48. 我所得到的都是静态的
```java
class Dog {
	public static void bark() {
		System.out.print("woof ");
	}
}

class Basenji extends Dog {
	public static void bark() {
	}
}

public class Bark {
	public static void main(String args[]) {
		Dog woofer = new Dog();
		Dog nipper = new Basenji();
		woofer.bark();
		nipper.bark();
	}
}
```
对静态方法的调用不存在任何动态的分派机制。
千万不要用一个表达式来标识一个静态方法调用。
千万不要隐藏静态方法。
49.	比生命更大
```java
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
	private final int beltSize;
	private static final int CURRENT_YEAR = Calendar.getInstance().get(
			Calendar.YEAR);

	private Elvis() {
		beltSize = CURRENT_YEAR - 1930;
	}

	public int beltSize() {
		return beltSize;
	}

	public static void main(String[] args) {
		System.out.println("Elvis wears a size " + INSTANCE.beltSize()
				+ " belt.");
	}
}
```
在final类型的静态字段被初始化之前，存在着读取其值的可能。
要想改正一个类初始化循环，需要重新对静态字段的初始器进行排序，使得每一个初始器都出现在任何依赖于它的初始器之前。
要当心类初始化循环。
50.	不是你的类型
```java
public class Type1 {
	public static void main(String[] args) {
		String s = null;
		System.out.println(s instanceof String);
	}
}
```
instanceof操作符被定义为在其左操作数为null时返回false。
```java
public class Type2 {
	public static void main(String[] args) {
		System.out.println(new Type2() instanceof String);
	}
}
```
instanceof操作符有这样的要求：如果两个操作数的类型都是类，其中一个必须是另一个的子类型。
```java
public class Type3 {
	public static void main(String args[]) {
		Type3 t3 = (Type3) new Object();
	}
}
```
51.	要点何在
```java
class Point {
	private final int x, y;
	private final String name; // Cached at construction time

	Point(int x, int y) {
		this.x = x;
		this.y = y;
		name = makeName();
	}

	protected String makeName() {
		return "[" + x + "," + y + "]";
	}

	public final String toString() {
		return name;
	}
}

public class ColorPoint extends Point {
	private final String color;

	ColorPoint(int x, int y, String color) {
		super(x, y);
		this.color = color;
	}

	protected String makeName() {
		return super.makeName() + ":" + color;
	}

	public static void main(String[] args) {
		System.out.println(new ColorPoint(4, 2, "purple"));
	}
}
```
在一个final类型的实例字段被赋值之前，存在着取用其值的可能。
循环的实例初始化时可以且总是应该避免的。
千万不要在构造器中调用可覆写的方法。
52.	总和的玩笑
```java
class Cache {
	static {
		initializeIfNecessary();
	}
	private static int sum;

	public static int getSum() {
		initializeIfNecessary();
		return sum;
	}

	private static boolean initialized = false;

	private static synchronized void initializeIfNecessary() {
		if (!initialized) {
			for (int i = 0; i < 100; i++)
				sum += i;
			initialized = true;
		}
	}
}

public class Client {
	public static void main(String[] args) {
		System.out.println(Cache.getSum());
	}
}
```
要么使用积极初始化，要么使用延迟初始化，千万不要同时使用二者。
请考虑类初始化的顺序，特别是当初始化显得很重要时更是如此。
53.	做你的事吧
54.	Null与Void
```java
public class Null {
	public static void greet() {
		System.out.println("Hello world!");
	}

	public static void main(String[] args) {
		((Null) null).greet();
	}
}
```
静态方法调用的限定表达式是可以计算的，但是它的值将被忽略。
```java
Null.greet();
greet();
```
55.	特创论
```java
public class Creator {
	public static void main(String[] args) {
		for (int i = 0; i < 100; i++)
			Creature creature = new Creature();
		System.out.println(Creature.numCreated());
	}
}

class Creature {
	private static long numCreated = 0;

	public Creature() {
		numCreated++;
	}

	public static long numCreated() {
		return numCreated;
	}
}
```
一个局部变量声明作为一条语句只能直接出现在一个语句块中。（一个语句块是由一对花括号以及包含在这对花括号的语句和声明构成的）
```java
		for (int i = 0; i < 100; i++) {
			Creature creature = new Creature();
		}

		for (int i = 0; i < 100; i++)
			new Creature();

// Thread-safe creation counter
class Creature {
	private static long numCreated;

	public Creature() {
		synchronized (Creature.class) {
			numCreated++;
		}
	}

	public static synchronized long numCreated() {
		return numCreated;
	}
}

class Creature {
	private static AtomicLong numCreated = new AtomicLong();

	public Creature() {
		numCreated.incrementAndGet();
	}

	public static long numCreated() {
		return numCreated.get();
	}
}
```
在使用一个变量来对实例的创建进行计数时，要使用long类型而不是int类型的变量，以防止溢出。
## 第7章 库之谜
56. 大问题
```java
public class BigProblem {
	public static void main(String[] args) {
		BigInteger fiveThousand = new BigInteger("5000");
		BigInteger fiftyThousand = new BigInteger("50000");
		BigInteger fiveHundredThousand = new BigInteger("500000");
		BigInteger total = BigInteger.ZERO;
		total.add(fiveThousand);
		total.add(fiftyThousand);
		total.add(fiveHundredThousand);
		System.out.println(total);
	}
}
```
BigInteger实例是不可变的。
```java
total = total.add(fiveThousand);
total = total.add(fiftyThousand);
total = total.add(fiveHundredThousand);
```
57.	名字里有什么
```java
public class Name {
	private final String first, last;

	public Name(String first, String last) {
		this.first = first;
		this.last = last;
	}

	public boolean equals(Object o) {
		if (!(o instanceof Name))
			return false;
		Name n = (Name) o;
		return n.first.equals(first) && n.last.equals(last);
	}

	public static void main(String[] args) {
		Set<Name> s = new HashSet<Name>();
		s.add(new Name("Mickey", "Mouse"));
		System.out.println(s.contains(new Name("Mickey", "Mouse")));
	}
}
```
无论何时，只要覆写了equals方法，就必须同时覆写hashCode方法。
58.	产生它的散列码
```java
public class Name {
	private final String first, last;

	public Name(String first, String last) {
		this.first = first;
		this.last = last;
	}

	public boolean equals(Name n) {
		return n.first.equals(first) && n.last.equals(last);
	}

	public int hashCode() {
		return 31 * first.hashCode() + last.hashCode();
	}

	public static void main(String[] args) {
		Set<Name> s = new HashSet<Name>();
		s.add(new Name("Donald", "Duck"));
		System.out.println(s.contains(new Name("Donald", "Duck")));
	}
}
```
重载为错误和混乱提供了机会。
为了避免无意识地重载，应该机械地对你想要覆写的每一个超类方法都复制其声明。
59. 差是什么
以0开头的整型字面常量将被解释成为八进制数值。
千万不要在一个整型字面常量前面加上一个0。
60. 一行以毙之
了解类库中有些什么可以为你节省大量的时间和精力，并且可以提高程序的速度和质量。
61. 日期游戏
Date将一月表示为0，而Calendar延续了这个错误。
Date.getDay返回的是Date实例所表示的星期日期，而不是月份日期。
在使用Calendar或Date的时候一定要当心，千万要记着查阅API文档。
62. 名字游戏
不要使用IdentityHashMap，除非你需要其基于标识的语义，它不是一个通用目的的Map实现。
63. 更多同样的问题
不要因为偶然地添加了一个返回类型，而将一个构造器声明变成了一个方法声明。
要遵守标准的命名约定。
64. 按余数编组
Math.abs不能保证一定会返回非负的结果。
65. 疑似配需的惊人传奇
不要使用基于减法的比较器，除非你能够确保要比较的数值之间的差永远不会大于Integer.MAX_VALUE。
## 第8章 更多类之谜
66. 一件私事
```java
class Base {
	public String className = "Base";
}

class Derived extends Base {
	private String className = "Derived";
}

public class PrivateMatter {
	public static void main(String[] args) {
		System.out.println(new Derived().className);
	}
}
```
避免隐藏。
一个覆写方法的访问修饰符所提供的访问权限要大于等于被覆写方法的访问修饰符所提供的访问权限。而字段则不必。
67.	对字符串上瘾
要避免重用平台类的名字，并且千万不要难过重用java.lang中的类名。
68.	灰色的阴影
```java
public class ShadesOfGray {
	public static void main(String[] args) {
		System.out.println(X.Y.Z);
	}
}

class X {
	static class Y {
		static String Z = "Black";
	}

	static C Y = new C();
}

class C {
	String Z = "White";
}
```
当一个变量和一个类型具有相同的名字，并且它们位于相同的作用域时，变量名具有优先权。
相似地，变量名和类型名可以遮掩包名。
69.	黑色的渐隐
70.	一揽子交易
```java
package click;
public class CodeTalk {
	public void doIt() {
		printMessage();
	}

	void printMessage() {
		System.out.println("Click");
	}
}

package hack;
import click.CodeTalk;
public class TypeIt {
	private static class ClickIt extends CodeTalk {
		void printMessage() {
			System.out.println("Hack");
		}
	}

	public static void main(String[] args) {
		ClickIt clickit = new ClickIt();
		clickit.doIt();
	}
}
```
一个包内私有的方法不能被位于另一个包中的某个方法直接覆写。
71.	进口税
72.	终极危难
final修饰符对方法和字段而言，意味着某些完全不同的事情。对于方法，final意味着该方法不能被覆写（对实例方法而言）或者隐藏（对静态方法而言）。对于字段，final意味着该字段不能被赋值超过一次。
73.	隐私在公开
重用名字是危险的；应该避免隐藏、遮蔽和遮掩。
74.	同一性的危机
75.	头还是尾
名字重用的术语表
第9章 更多库之谜
76.	乒乓
```java
public class PingPong {
	public static synchronized void main(String[] a) {
		Thread t = new Thread() {
			public void run() {
				pong();
			}
		};
		t.run();
		System.out.print("Ping");
	}

	static synchronized void pong() {
		System.out.print("Pong");
	}
}
```
当你想调用一个线程的start方法时要多加小心，别弄错成调用这个线程的run方法了。
77.	乱锁之妖
78.	反射的影响
```java
public class Reflector {
	public static void main(String[] args) throws Exception {
		Set<String> s = new HashSet<String>();
		s.add("foo");
		Iterator it = s.iterator();
		Method m = it.getClass().getMethod("hasNext");
		System.out.println(m.invoke(it));
	}
}
```
访问位于其它包中的非公共类型的成员是不合法的。
Object.getClass().getMethod(“methodName”)这种惯用法虽然很常见，但是却有问题，它不应该被使用。
在使用反射访问某个类型时，请使用表示某种可访问类型的Class对象。
Method m = Iterator.class.getMethod("hasNext");
79.	狗狗的幸福生活
避免遮蔽。
使用Thread(Runnable)构造器来替代对Thread的继承。
80.	更深层的反射
```java
public class Outer {
	public static void main(String[] args) throws Exception {
		new Outer().greetWorld();
	}

	private void greetWorld() throws Exception {
		System.out.println(Inner.class.newInstance());
	}

	public class Inner {
		public String toString() {
			return "Hello world";
		}
	}
}
```
除非你确实需要一个外围实例i，否则应该优先使用静态成员类而不是非静态成员类。
请避免使用反射类实例化内部类。
81.	无法识别的字符化
```java
public class Greeter {
	public static void main(String[] args) {
		String greeting = "Hello world";
		for (int i = 0; i < greeting.length(); i++)
			System.out.write(greeting.charAt(i));
	}
}
```
write(int)是唯一一个在自动刷新功能开启的情况下不刷新PrintStream的输出方法。
尽可能使用熟悉的惯用法，如果不得不使用陌生的API，请一定要参考相关的文档。
82.	啤酒爆炸
83.	诵读困难者的一神论
84.	戛然而止
```java
public class SelfInterruption {
	public static void main(String[] args) {
		Thread.currentThread().interrupt();
		if (Thread.interrupted()) {
			System.out.println("Interrupted: " + Thread.interrupted());
		} else {
			System.out.println("Not interrupted: " + Thread.interrupted());
		}
	}
}
```
调用Thread.interrupted方法总是会清除当前线程的中断状态。
Thread.currentThread().isInterrupted()
不要使用Thread.interrupted方法，除非你想要清除当前线程的中断状态。
85.	延迟初始化






